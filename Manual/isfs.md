<h1>isfs</h1>
<h2>Function</h2>

Calculates self-part of the intermediate scattering function over a specified range of wavenumbers. For a given wavenumber, the underlying code computes the function first over a wavevector corresponding to that wavenumber. It performs this computation at multiple such wavevectors corresponding to that wavenumber, and then averages over all such wavevectors to compute the result at the specified wavenumber.

$$  F_s(q,\Delta t) = \frac{1}{H} \sum_{h=1}^{H} \sum_{j=1}^{S} \sum_{i=1}^{N(s)} \cos\left((\vec{q}_h \cdot (\vec{r}_i(s_j+\Delta t)-\vec{r}_i(s_j))\right)   $$

where H is the number of wavevectors employed corresponding to the specified wavenumber, S is the number of start times employed, N is the number of particles, $\boldsymbol{r}_i(t)$ is the position of particle $i$ at time $t$, and $\Delta t$ is a timegap. 

The use of the cosine transform rather than the full fourier transform reflects the use of symmetry.

This list of wavevectors employed for a given wavenumber is determined in the following manner. A three-dimensional cubic grid is defined in inverse space, with grid spacing equal to $\frac{2\pi}{L}$. 

$L$ is set equal to the \<max\_length\_scale\> variable specified below, unless that quantity is set to 0 or negative. In that case L is set equal to the smallest dimension of the box. This tunable choice of L is possible because the self-intermediate scattering function employs a difference in a particle's position rather than absolute positions, which is an inherently 'unwrapped' quantity in that it has no dependence on box size (in contrast, structure factor calculations, for example, must employ actual box dimensions for exact accuracy).

These wavevectors are then binned into bins corresponding to distinct wavenumbers, which correspond to spherical shells in three dimensional inverse space. In 3-d space, this allows calculation of wavenumbers spaced more closely than $\frac{2\pi}{L}$, which would not be possible in a one-dimensional Fourier transform.  AMDAT employs a spacing of $\frac{\pi}{L}$ for this binning, corresponding to bin thicknesses half the spacing of the underlying grid in inverse space. Wavenumber bins are thus centered at positions of $q_m=\frac{\pi}{2L}+\frac{m\pi}{L}$, where $m$ is the index of the wavenumber. It is this index $m$ that is employed in the wavenumber index fields below. The wavenumber reported in the output file generated by this analysis reports this nominal wavenumber at the center of the bin of wavevectors (as opposed to an actual average location of the magnitude of the wavevectors employed). Except at very low wavenumber indices, the difference between these quantities is generally quite small, but this may be updated in a future version of AMDAT.

In averaging over wavevectors for a given wavenumber, a maximum number of wavevectors of 300 is employed for computational efficiency. This means that all wavevectors are employed for wavenumber indices up to 16; for higher indices a subset of 300 are employed. These 300 are randomly chosen from the set of all wavevectors. These wavevector lists are hard-coded into AMDAT for computational efficiency and are therefore the same each time AMDAT is run. 

<h2>Syntax</h2>

_isfs \<output file\> \>\<first wavenumber index\> \<last wavenumber index\> \<geometry\> \<max\_length\_scale\> \<(optional) fullblock\>_

_\<target\>_

_\<first wavevector index\> and \<lastwavevector index\>_ give the limits wave vectors to be calculated. Options for _\<geometry\>_ are _xyz, xy, xz, yz, x, y,_ and _z_. This chooses which dimensions in k-space to include in the calculation of the intermediate scattering function. _xyz_ computes the full radial three dimensional isf, _xy, yz, and xz_ calculate two-dimensional in-plane radial isf's, and _x, y, and z_ compute one-dimensional isf's. _\<max\_length\_scale\>_ determines the longest distance which will be decomposed into inverse space. If a distance of 0 is given, the full box size is used_. \<(optional) fullblock\>_ is an optional argument that can be either 0 or 1. The default is 0, in which case time spacings spanning multiple blocks use only the first time of each block. A setting of 1 specifies that it should use all block times for times spanning blocks. This may result in substantial computational time increases but offers the possibility of modestly increased data quality at very long times.
